/*!
 * This is the Client of the Banking Task. It does support the varous tasks for viewing the balance 
 * and transfering money over a simple CLI Input. 
 *
 * @brief The Client of the Banking Task.
 * @author Raphael Ludwig (e1526280)
 * @version 1
 * @date 12 Dez. 2016
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <semaphore.h>
#include <stdbool.h>
#include <fcntl.h>
#include <string.h>
#include <signal.h>

/**
 * The shared.h Header does contain all 
 * definitions and constances which are
 * needed by the server and client
 */
#include "shared.h"


/* === Type Definitions === */

/**
 * @brief This structure does hold all relevant data for the client connection
 */
struct ClientConnection {
	/** @brief the shared resources with the server (semaphores and shared memory) */	
	struct BankServer server;
	
	/** @brief the account number, used to identify the account */
	int accountNR;
	/** @brief secret which is generated by the server, used to authenticate the user */	
	int secret;

	/** @brief the balance which is read by get_balance (might change on server, so no reuse!) */
	int balance;
	/** @brief a flag which does indicate if we are still connected to the server */
	bool connected;
	/** @brief a flag which does inidcate if the bank wrote to us that it's closed */
	bool bankClosed;
};

/* === Globals === */

/**
 * @brief The Base name of the Program which is displayed in the error message
 */
static const char *progname = "bankclient";

/**
 * @brief a global variable which does store the connecion information of the client
 */
static struct ClientConnection *con = NULL;

/**
 * @brief Variable which is set to 1 by the signal_handler if SIGINT or SIGTERM was recieved
 */
static sig_atomic_t stopSignal = 0;

/* === Prototypes === */

/**
 * @brief This Method does initalize the shared resources with the server, if anything bad happens it will call exit(EXIT_FAILURE)
 * @param server structure which should be initalized
 */
static void init_bankserver(struct BankServer *server);

/**
 * @brief This Method does connect to the bank and requests the secret
 * @param connection structure which contains the connection data to the server
 * @return true if action was successful otherwise false
 */
static bool connect_to_bank(struct ClientConnection *connection);

/**
 * @brief This Method does send the bank disconnect message, must contain a valid secret to work
 * @param connection structure which contains the connection data to the server
 * @return true if action was successful otherwise false
 */
static bool disconnect_from_bank(struct ClientConnection *connection);

/**
 * @brief This Method does send the get balance message to the server and saves the result in connection
 * @param connection structure which contains the connection data to the server
 * @return true if action was successful otherwise false
 */
static bool get_balance(struct ClientConnection *connection);

/**
 * @brief This Method does send the withdraw message to the server 
 * @param connection structure which contains the connection data to the server
 * @param money how much money should be withdrawed from the bank account
 * @return true if action was successful otherwise false
 */
static bool withdraw_money(struct ClientConnection *connection,int money);

/**
 * @brief This Method does send the deposit message to the server
 * @param connection structure which contains the connection data to the server
 * @param money how much money should be deposited on the server
 * @return true if action was successful otherwise false
 */
static bool deposit_money(struct ClientConnection *connection,int money);

/**
 * @brief This Method does 
 * @param connection structure which contains the connection data to the server
 * @param money how much money should be transfered
 * @param accNtr the account number of the other account
 * @return true if action was successful otherwise false
 */
static bool transfer_money(struct ClientConnection *connection,int money,int acctNr);


/**
 * @brief prints the usage to stdout
 */
static void print_usage(void);

/**
 * @brief handles the signals
 * @param signal the signal for the signal handler 
 */
static void signal_handler(int signal);

/**
 * @brief parses the arguments and directly sets the accountNR in the global variable
 * @param argc number of arguments
 * @param argv the arguments from main
 */
static void parse_arguments(int argc,char *argv[]);

/**
 * @brief this function does install all the signal handlers which are needed
 */
static void install_signal_handlers(void);

/**
 * @brief disconnects from the server and frees all the private and shared resources 
 */
static void free_resources(void);


/**
 * @brief this method does read an integer from the stdin fd
 * @return the integer which was read from stdin
 */
static int read_int_from_stdin(void);

/**
 * This function represents the entry point to the Bankclient. After starting the client
 * will take the first argv parameter and try to connect to the server with it as AccountNR.
 *
 * @brief main function of the client
 * @param argc argument counter of how many arguments
 * @param argv the actual agruments for this program
 * @return EXIT_SUCCESS or EXIT_FAILURE
 */
int main(int argc,char **argv) {
	/* Basic Memory alloc for the Application */
	con = (struct ClientConnection *) malloc( sizeof(struct ClientConnection) );	
	if( con == NULL ) {
		perror("malloc");
		exit(EXIT_FAILURE);
	}
	
	/* Setting some flags & registering the exit handler */
	con->connected  = false;
	con->bankClosed = false;
	if( atexit(free_resources) < 0 ) {
		perror("atexit");
		exit(EXIT_FAILURE);
	}	
	
	/* Install signal handlers and start processing input */
	install_signal_handlers();
	init_bankserver(&con->server);
	parse_arguments(argc,argv);
	
	/* Try connect to the server */
	(void) fprintf( stdout , "Connecting to Server with AccountNr: %d\n", con->accountNR );
	if( connect_to_bank(con) == false ) {
		(void) fprintf( stdout , "Connecting to the Server was not possible!\n" );
		exit(EXIT_FAILURE);
	}
	
	con->connected = true;

	//Do work as long as SIGINT was not recieved
	(void) fprintf( stdout , "HINT: Enter 'h' to view the help page" );
	int money = 0;
	while( stopSignal == 0 ) {
		
		(void) fprintf( stdout , "\nEnter your action [t,b,w,d,x]: " ); 
		switch( getc( stdin ) ) {
			case 't':
				(void) getc( stdin ); //Consume ENTER
				(void) fprintf( stdout , "\nEnter the other AccountNr.: " );
				int otherAcc = read_int_from_stdin();
				
				(void) fprintf( stdout , "\nEnter the amount you want to transfer: ");
				money = read_int_from_stdin();
				
				if( transfer_money(con,money,otherAcc) ) (void) fprintf( stdout , "\nMoney was succesfully transfered" );
				else (void) fprintf( stdout , "\nUnable to transfer that amount to the other account!");
				break;
			case 'b':
				(void) getc( stdin ); //consume ENTER 
				if( get_balance(con) ) (void) fprintf( stdout , "\nBalance: %d", con->balance );
				else (void) fprintf( stdout , "\nUnable to read Balance!" );
				break;
			case 'w':
				(void) getc( stdin ); //Consume ENTER
				(void) fprintf( stdout , "\nEnter the amount you want to withdraw: ");
				money = read_int_from_stdin();

				if( withdraw_money(con,money) ) (void) fprintf( stdout , "\nMoney was succesfully withdrawed");
				else (void) fprintf( stdout , "\nUnable to deposit the Money!");
				break;
			case 'd': 
				(void) getc( stdin ); //Consume ENTER
				(void) fprintf( stdout , "\nEnter the amount you want to deposit: ");
				money = read_int_from_stdin();

				if( deposit_money(con,money) ) (void) fprintf( stdout , "\nMoney was succesfully despoited");
				else (void) fprintf( stdout , "\nUnable to deposit the Money!");
				break;
			case 'x': 
				stopSignal = 1; 
				break;
			case 'h':
				(void) getc( stdin ); //consume ENTER
				(void) fprintf( stdout , "\nt\t\t Transfer Money to an other Account\n" );
				(void) fprintf( stdout , "b\t\t To view your Balance\n" );
				(void) fprintf( stdout , "w\t\t Withdraw some Money form your Account\n" );
				(void) fprintf( stdout , "d\t\t Deposit Money into your Account\n" );
				(void) fprintf( stdout , "x\t\t Exits the Programm\n" );
				break;
			default :
				(void) getc( stdin ); //consume ENTER 
				(void) fprintf( stdout , "Unknown Input, press 'h' for Help.\n");
		}

		if( con->bankClosed ) {
			(void) fprintf( stdout , "\nBank was closed, client will now disconnect ...");
			stopSignal = 1;
		}
	}
	
	/* Disconnect from bank (Needed here? -> can be done in free_resources) */
	(void) disconnect_from_bank(con);
	con->connected = false;

	return EXIT_SUCCESS; 		  // free_resources is called implicitly 
}

static void init_bankserver(struct BankServer *server) {
	//Set the values to default values in case of errors 
	server->client_lock 	= SEM_FAILED;
	server->server_lock	= SEM_FAILED;
	server->readBack_lock	= SEM_FAILED;
	server->shared		= MAP_FAILED;	
	server->bankmgr		= -1;

	server->client_lock = sem_open(BANK_CONNECT_CLIENT_LOCK,0);
	if( server->client_lock == SEM_FAILED ) {
		(void) fprintf( stdout , "Could not aquire client_lock, is the Bankserver running?\n" );
		perror("client_lock");
		exit(EXIT_FAILURE);
	}
	
	server->server_lock = sem_open(BANK_CONNECT_SERVER_LOCK,0);
	if( server->server_lock == SEM_FAILED ) {
		perror("server_lock");
		exit(EXIT_FAILURE);
	}

	server->readBack_lock = sem_open(BANK_CONNECT_READ_LOCK,0);
	if( server->readBack_lock == SEM_FAILED ) {
		perror("read_lock");
		exit(EXIT_FAILURE);
	}

	server->bankmgr = shm_open(BANK_CONNECT_SHM, O_RDWR, 0660);
	if( server->bankmgr == -1 ) {
		perror("bankmgr shm");
		exit(EXIT_FAILURE);
	}	
	
	server->shared = mmap(NULL, sizeof(struct BankMgrData),PROT_READ | PROT_WRITE, MAP_SHARED,server->bankmgr, 0);
	if( server->shared == MAP_FAILED ) {
		perror("mmap");
		exit(EXIT_FAILURE);
	}
}

static void communicate_with_bank(struct ClientConnection *connection,struct BankMgrData *data) {
        sem_wait(connection->server.client_lock); 

	if( connection->server.shared->action == BANK_CLOSED ) {
		data->outcome = false;
		connection->bankClosed = true;
		return; //So bank is closed ... will return 
	}
	
	(void) memcpy(connection->server.shared,data,sizeof(struct BankMgrData));

        sem_post(connection->server.server_lock);  // Signal Server it's time to process 
        sem_wait(connection->server.readBack_lock);  // wait for server to finish processing
 	
	(void) memcpy(data,connection->server.shared,sizeof(struct BankMgrData));
}

static bool connect_to_bank(struct ClientConnection *connection) {
        struct BankMgrData data = {
                .action 	= BANK_ACTION_CONNECT,
		.accountNr 	= connection->accountNR,
                .secret 	= connection->secret,
                .outcome 	= false
        };
	
	communicate_with_bank(connection,&data);
	
	connection->secret = data.secret;
	sem_post(connection->server.client_lock);  // Signal other clients that we are finished
        return data.outcome;
}

static bool disconnect_from_bank(struct ClientConnection *connection) {
        struct BankMgrData data = {
                .action 	= BANK_ACTION_DISCONNECT,
		.accountNr 	= connection->accountNR,
                .secret 	= connection->secret,
                .outcome 	= false
        };

       	communicate_with_bank(connection,&data);
        sem_post(connection->server.client_lock);  // Signal other clients that we are finished
	return data.outcome;
}

static bool get_balance(struct ClientConnection *connection) {
	struct BankMgrData data = {
                .action 	= BANK_ACTION_GET_BALANCE,
		.accountNr 	= connection->accountNR,
                .secret 	= connection->secret,
                .outcome 	= false
        };
	
	communicate_with_bank(connection,&data);

	connection->balance = data.data;
        sem_post(connection->server.client_lock);  // Signal other clients that we are finished
	return data.outcome;
}

static bool withdraw_money(struct ClientConnection *connection,int money) {
	struct BankMgrData data = {
                .action 	= BANK_ACTION_MONEY_WITHDRAW,
		.accountNr 	= connection->accountNR,
                .secret 	= connection->secret,
		.data 		= money,
                .outcome 	= false
        };

	communicate_with_bank(connection,&data);
        sem_post(connection->server.client_lock);  // Signal other clients that we are finished
	return data.outcome;	
}

static bool deposit_money(struct ClientConnection *connection,int money) {
	struct BankMgrData data = {
                .action 	= BANK_ACTION_MONEY_DEPOSIT,
		.accountNr 	= connection->accountNR,
                .secret 	= connection->secret,
		.data 		= money,
                .outcome 	= false
        };

	communicate_with_bank(connection,&data);
        sem_post(connection->server.client_lock);  // Signal other clients that we are finished	
	return data.outcome;		
}

static bool transfer_money(struct ClientConnection *connection,int money,int acctNr) {
	struct BankMgrData data = {
                .action 	= BANK_ACTION_MONEY_TRANSFER,
		.accountNr 	= connection->accountNR,
                .secret 	= connection->secret,
		.data 		= money,
		.otherAcc 	= acctNr,
                .outcome 	= false
        };

	communicate_with_bank(connection,&data);
        sem_post(connection->server.client_lock);  // Signal other clients that we are finished	
	return data.outcome;
}

static void parse_arguments(int argc,char *argv[]) {
	if( argc == 0 ) {
		(void) fprintf( stderr , "Unable to parse commandline!");
		exit(EXIT_FAILURE);
	}
	progname = argv[0];

	if( argc < 2 || argv[1][1] == '-' || argc > 2 ) {
		print_usage();
	}

	con->accountNR = strtol(argv[1],NULL,10);
}

static void install_signal_handlers(void) {
	struct sigaction s;
	
	s.sa_handler = signal_handler;
	s.sa_flags   = 0;
	
	if( sigfillset(&s.sa_mask) < 0 ) {
		perror("sigfillset");
		exit(EXIT_FAILURE);
	}

	if( sigaction(SIGINT,&s,NULL) < 0 ) {
		perror("sigfillset");
		exit(EXIT_FAILURE);
	}

	if( sigaction(SIGTERM,&s,NULL) < 0 ) {
		perror("sigfillset");
		exit(EXIT_FAILURE);
	}

}

static void free_resources(void) {
	(void) fprintf( stdout , "free_resources()\n" );
	
	//Try to disconnect ....
	if ( con->connected ) //if connected skip otherwise test for any problems	
	if ( con != NULL 
        &&   con->server.shared != MAP_FAILED
	&&   con->server.client_lock   != SEM_FAILED 
	&&   con->server.server_lock   != SEM_FAILED 
	&&   con->server.readBack_lock != SEM_FAILED )
		(void) disconnect_from_bank(con);

	if( con->server.shared != MAP_FAILED ) munmap(con->server.shared,sizeof(struct BankMgrData));
	
	if( con->server.client_lock   != SEM_FAILED ) sem_close(con->server.client_lock);
	if( con->server.server_lock   != SEM_FAILED ) sem_close(con->server.server_lock);
	if( con->server.readBack_lock != SEM_FAILED ) sem_close(con->server.readBack_lock);

	if( con != NULL ) free(con);
}

static void signal_handler(int signal) {
	stopSignal = 1;
}

static void print_usage(void) {
	(void) fprintf( stdout , "%s: <account-nr>", progname );
	exit( EXIT_FAILURE );
}

static int read_int_from_stdin(void) {
	const int BUFFER_SIZE = 32;
	char line[BUFFER_SIZE];
	
	(void) fgets(line, BUFFER_SIZE, stdin);
	return strtol(line,NULL,10);
}

